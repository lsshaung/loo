<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: DW_axi_x2p_bcm21</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | <a href="groups.html" ><b>groups</b></a> | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_DW_axi_x2p_bcm21'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_DW_axi_x2p_bcm21')">DW_axi_x2p_bcm21</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 67.14</td>
<td class="s7 cl rt"><a href="mod16.html#Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#Toggle" > 91.43</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/ICer/axi_to_apb_uvm/sim_v1.0/script/../../rtl/DW_axi_x2p_bcm21.v')">/home/ICer/axi_to_apb_uvm/sim_v1.0/script/../../rtl/DW_axi_x2p_bcm21.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left class="sortable">
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_20"  onclick="showContent('inst_tag_20')">axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_20_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_20_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_20_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_20_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_21"  onclick="showContent('inst_tag_21')">axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_21_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_21_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_21_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_21_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_22"  onclick="showContent('inst_tag_22')">axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_22_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_22_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_22_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_22_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_23"  onclick="showContent('inst_tag_23')">axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_23_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_23_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_23_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_23_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_24"  onclick="showContent('inst_tag_24')">axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_24_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_24_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_24_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_24_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_25"  onclick="showContent('inst_tag_25')">axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_25_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_25_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_25_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_25_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_18"  onclick="showContent('inst_tag_18')">axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_18_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_18_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_18_Toggle" > 92.86</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_18_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod16.html#inst_tag_19"  onclick="showContent('inst_tag_19')">axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></td>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_19_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_19_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_19_Toggle" > 92.86</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_19_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
<div name='inst_tag_20'>
<hr>
<a name="inst_tag_20"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_20" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_20_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_20_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_20_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_20_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 76.38</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s6 cl rt"> 67.65</td>
<td class="s8 cl rt"> 83.91</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 78.95</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_28" >U_PUSH_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_21'>
<hr>
<a name="inst_tag_21"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_21" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_21_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_21_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_21_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_21_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 76.38</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s6 cl rt"> 67.65</td>
<td class="s8 cl rt"> 83.91</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 78.95</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_29" >U_POP_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_22'>
<hr>
<a name="inst_tag_22"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_22" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_22_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_22_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_22_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_22_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 69.41</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s5 cl rt"> 58.82</td>
<td class="s7 cl rt"> 70.11</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 73.68</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_30" >U_PUSH_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_23'>
<hr>
<a name="inst_tag_23"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_23" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_23_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_23_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_23_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_23_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 70.72</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s6 cl rt"> 61.76</td>
<td class="s7 cl rt"> 72.41</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 73.68</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_31" >U_POP_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_24'>
<hr>
<a name="inst_tag_24"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_24" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_24_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_24_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_24_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_24_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 76.38</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s6 cl rt"> 67.65</td>
<td class="s8 cl rt"> 83.91</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 78.95</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_32" >U_PUSH_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_25'>
<hr>
<a name="inst_tag_25"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_25" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_25_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_25_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_25_Toggle" > 90.00</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_25_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 90.00</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 76.38</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s6 cl rt"> 67.65</td>
<td class="s8 cl rt"> 83.91</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 78.95</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_33" >U_POP_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_18'>
<hr>
<a name="inst_tag_18"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_18" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_18_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_18_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_18_Toggle" > 92.86</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_18_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 92.86</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 66.78</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s5 cl rt"> 55.88</td>
<td class="s6 cl rt"> 67.83</td>
<td class="wht cl rt"></td>
<td class="s6 cl rt"> 68.42</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_26" >U_PUSH_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_19'>
<hr>
<a name="inst_tag_19"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_19" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"><a href="mod16.html#inst_tag_19_Line" > 70.00</a></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_19_Cond" > 50.00</a></td>
<td class="s9 cl rt"><a href="mod16.html#inst_tag_19_Toggle" > 92.86</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod16.html#inst_tag_19_Branch" > 57.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s7 cl rt"> 70.00</td>
<td class="s5 cl rt"> 50.00</td>
<td class="s9 cl rt"> 92.86</td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"> 57.14</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s7 cl rt"> 70.89</td>
<td class="s7 cl rt"> 75.00</td>
<td class="s7 cl rt"> 70.59</td>
<td class="s6 cl rt"> 69.57</td>
<td class="wht cl rt"></td>
<td class="s6 cl rt"> 68.42</td>
<td class="wht cl rt"></td>
<td><a href="mod17.html#inst_tag_27" >U_POP_FIFOFCTL</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_DW_axi_x2p_bcm21'>
<a name="Line"></a>
Line Coverage for Module : <a name="926011255"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a name="813572420"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21 ( parameter WIDTH=3,F_SYNC_TYPE=10,TST_MODE=0,VERIF_EN=1,SVA_TYPE=2 ) </a><br clear=all>
Cond Coverage for Module self-instances : 
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_18_Cond" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_19_Cond" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a name="1136727835"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21 ( parameter WIDTH=2,F_SYNC_TYPE=10,TST_MODE=0,VERIF_EN=1,SVA_TYPE=2 ) </a><br clear=all>
Cond Coverage for Module self-instances : 
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_20_Cond" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_21_Cond" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_22_Cond" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_23_Cond" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_24_Cond" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>COND</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s5 cl rt"> 50.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_25_Cond" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a name="813572420"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21 ( parameter WIDTH=3,F_SYNC_TYPE=10,TST_MODE=0,VERIF_EN=1,SVA_TYPE=2 ) </a><br clear=all>
Toggle Coverage for Module self-instances : 
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s9 cl rt"> 92.86</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_18_Toggle" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 67.50</td>
<td class="s9 cl rt"> 92.86</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_19_Toggle" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">56</td>
<td class="rt">52</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">20</td>
<td class="rt">16</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 0->1</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">36</td>
<td class="rt">36</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a name="1136727835"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21 ( parameter WIDTH=2,F_SYNC_TYPE=10,TST_MODE=0,VERIF_EN=1,SVA_TYPE=2 ) </a><br clear=all>
Toggle Coverage for Module self-instances : 
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_20_Toggle" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_21_Toggle" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_22_Toggle" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_23_Toggle" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_24_Toggle" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<div>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>TOGGLE</td></tr><tr>
<td class="s6 cl rt"> 66.79</td>
<td class="s9 cl rt"> 90.00</td>
</tr></table>
<span class=inst><a href="mod16.html#inst_tag_25_Toggle" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></span></div>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a name="926011255"></a>
<a href="mod16.html" >DW_axi_x2p_bcm21</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_20'>
<a name="inst_tag_20_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_20" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_20_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_20" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_20_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_20" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_20_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_20" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_21'>
<a name="inst_tag_21_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_21" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_21_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_21" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_21_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_21" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_21_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_21" >axi_bus_top.DW_axi_x2p_u.U_WR_DATA_BUFF.U_WRITE_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_22'>
<a name="inst_tag_22_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_22" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_22_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_22" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_22_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_22" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_22_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_22" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_23'>
<a name="inst_tag_23_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_23" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_23_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_23" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_23_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_23" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_23_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_23" >axi_bus_top.DW_axi_x2p_u.U_RESP_BUFF.U_RESP_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_24'>
<a name="inst_tag_24_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_24" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_24_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_24" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_24_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_24" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_24_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_24" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_25'>
<a name="inst_tag_25_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_25" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_25_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_25" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_25_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_25" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">40</td>
<td class="rt">36</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">20</td>
<td class="rt">18</td>
<td class="rt">90.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>Port Bits</td>
<td class="rt">16</td>
<td class="rt">12</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 1->0</td>
<td class="rt">8</td>
<td class="rt">6</td>
<td class="rt">75.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">24</td>
<td class="rt">24</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">12</td>
<td class="rt">12</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_25_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_25" >axi_bus_top.DW_axi_x2p_u.U_RD_DATA_BUFF.U_READ_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_18'>
<a name="inst_tag_18_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_18" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_18_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_18" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_18_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_18" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">56</td>
<td class="rt">52</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">20</td>
<td class="rt">16</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 0->1</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">36</td>
<td class="rt">36</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_18_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_18" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_PUSH_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_19'>
<a name="inst_tag_19_Line"></a>
<b>Line Coverage for Instance : <a href="mod16.html#inst_tag_19" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s7"><td class="lf">TOTAL</td><td></td><td>10</td><td>7</td><td>70.00</td></tr>
<tr class="s5"><td class="lf">INITIAL</td><td>86</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>603</td><td>8</td><td>6</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
85                        initial begin
86         1/1              if ((F_SYNC_TYPE &gt; 0)&amp;&amp;(F_SYNC_TYPE &lt; 8))
87         <font color = "red">0/1     ==>         $display(&quot;Information: *** Instance %m module is using the &lt;Double Register Synchronizer (1)&gt; Clock Domain Crossing Method ***&quot;);</font>
                        MISSING_ELSE
88                        end
89                      
90                      `endif
91                      `endif
92                      
93                      
94                      
95                      `ifdef SYNTHESIS
96                        assign data_s_int = data_s;
97                      `else
98                        `ifdef DW_MODEL_MISSAMPLES
99                        initial begin
100                         $display(&quot;Information: %m: *** Running with DW_MODEL_MISSAMPLES defined, VERIF_EN is: %0d ***&quot;,
101                                             VERIF_EN);
102                       end
103                     
104                     reg  [WIDTH-1:0]        test_hold_ms;
105                     reg  [WIDTH-1:0]        last_data_dyn, data_s_delta_t;
106                     reg  [WIDTH-1:0]        last_data_s, last_data_s_q, last_data_s_qq;
107                     wire [WIDTH-1:0]        data_s_sel_0, data_s_sel_1;
108                     reg  [WIDTH-1:0]        data_select; initial data_select = 0;
109                     reg  [WIDTH-1:0]        data_select_2; initial data_select_2 = 0;
110                     
111                       always @ (negedge clk_d or negedge rst_d_n) begin : PROC_test_hold_ms_registers
112                         if (rst_d_n == 1'b0) begin
113                           test_hold_ms        &lt;= {WIDTH{1'b0}};
114                         end else if (init_d_n == 1'b0) begin
115                           test_hold_ms        &lt;= {WIDTH{1'b0}};
116                         end else begin
117                           test_hold_ms        &lt;= data_s;
118                         end
119                       end
120                     
121                     reg                     init_dly_n;
122                     
123                     
124                       generate if ((VERIF_EN % 2) == 1) begin : GEN_HO_VE_ODD
125                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
126                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
127                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
128                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
129                           end // PROC_catch_last_data
130                     
131                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
132                             if (rst_d_n == 1'b0) begin
133                               last_data_s &lt;= {WIDTH{1'b0}};
134                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
135                             end else if (init_d_n == 1'b0) begin
136                               last_data_s &lt;= {WIDTH{1'b0}};
137                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
138                             end else begin
139                               last_data_s &lt;= data_s;
140                               if (clk_d_stopped == 1'b1)
141                                 last_data_s_qq &lt;= data_s;
142                               else
143                                 last_data_s_qq &lt;= last_data_s_q;
144                             end
145                           end
146                         end else begin : GEN_HO_FST_NE_1
147                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_EVEN
148                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
149                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
150                           end // PROC_catch_last_data
151                     
152                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_EVEN
153                             if (rst_d_n == 1'b0) begin
154                               last_data_s &lt;= {WIDTH{1'b0}};
155                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
156                             end else if (init_d_n == 1'b0) begin
157                               last_data_s &lt;= {WIDTH{1'b0}};
158                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
159                             end else begin
160                               last_data_s &lt;= data_s;
161                               if (clk_d_stopped == 1'b1)
162                                 last_data_s_qq &lt;= data_s;
163                               else
164                                 last_data_s_qq &lt;= last_data_s_q;
165                             end
166                           end
167                         end
168                       end else begin : GEN_HO_VE_EVEN
169                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_HO_FST_EQ_1
170                           always @ (posedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
171                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
172                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
173                           end // PROC_catch_last_data
174                     
175                           always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
176                             if (rst_d_n == 1'b0) begin
177                               last_data_s &lt;= {WIDTH{1'b0}};
178                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
179                             end else if (init_d_n == 1'b0) begin
180                               last_data_s &lt;= {WIDTH{1'b0}};
181                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
182                             end else begin
183                               last_data_s &lt;= data_s;
184                               if (clk_d_stopped == 1'b1)
185                                 last_data_s_qq &lt;= data_s;
186                               else
187                                 last_data_s_qq &lt;= last_data_s_q;
188                             end
189                           end
190                         end else begin : GEN_HO_FST_NE_1
191                           always @ (negedge clk_d or data_s or rst_d_n) begin : PROC_catch_last_data_VE_ODD
192                             data_s_delta_t &lt;= data_s &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
193                             last_data_dyn &lt;= ((clk_d_stopped==1'b1) ? data_s : data_s_delta_t) &amp; {WIDTH{rst_d_n}} &amp; {WIDTH{init_dly_n}};
194                           end // PROC_catch_last_data
195                     
196                           always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_odd_VE_ODD
197                             if (rst_d_n == 1'b0) begin
198                               last_data_s &lt;= {WIDTH{1'b0}};
199                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
200                             end else if (init_d_n == 1'b0) begin
201                               last_data_s &lt;= {WIDTH{1'b0}};
202                               last_data_s_qq  &lt;= {WIDTH{1'b0}};
203                             end else begin
204                               last_data_s &lt;= data_s;
205                               if (clk_d_stopped == 1'b1)
206                                 last_data_s_qq &lt;= data_s;
207                               else
208                                 last_data_s_qq &lt;= last_data_s_q;
209                             end
210                           end
211                         end
212                       end endgenerate
213                     
214                       generate if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_LDSQ_FST_EQ_1
215                         always @ (negedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
216                           if (rst_d_n == 1'b0) begin
217                             last_data_s_q  &lt;= {WIDTH{1'b0}};
218                             init_dly_n     &lt;= 1'b1;
219                           end else if (init_d_n == 1'b0) begin
220                             last_data_s_q  &lt;= {WIDTH{1'b0}};
221                             init_dly_n     &lt;= 1'b0;
222                           end else begin
223                             if (clk_d_stopped == 1'b1)
224                               last_data_s_q &lt;= data_s;
225                             else
226                               last_data_s_q &lt;= last_data_s;
227                             init_dly_n     &lt;= 1'b1;
228                           end
229                         end // PROC_missample_hist_even
230                       end else begin : GEN_LDSQ_FST_NE_1
231                         always @ (posedge clk_d or negedge rst_d_n) begin : PROC_missample_hist_even
232                           if (rst_d_n == 1'b0) begin
233                             last_data_s_q  &lt;= {WIDTH{1'b0}};
234                             init_dly_n     &lt;= 1'b1;
235                           end else if (init_d_n == 1'b0) begin
236                             last_data_s_q  &lt;= {WIDTH{1'b0}};
237                             init_dly_n     &lt;= 1'b0;
238                           end else begin
239                             if (clk_d_stopped == 1'b1)
240                               last_data_s_q &lt;= data_s;
241                             else
242                               last_data_s_q &lt;= last_data_s;
243                             init_dly_n     &lt;= 1'b1;
244                           end
245                         end // PROC_missample_hist_even
246                       end endgenerate
247                     
248                       always @ (data_s or last_data_s) begin : PROC_mk_next_data_select
249                         if (data_s !== last_data_s) begin
250                           data_select = wide_random(WIDTH);
251                     
252                           if ((VERIF_EN == 2) || (VERIF_EN == 3))
253                             data_select_2 = wide_random(WIDTH);
254                           else
255                             data_select_2 = {WIDTH{1'b0}};
256                         end
257                       end  // PROC_mk_next_data_select
258                     
259                       assign data_s_sel_0 = (clk_d_stopped==1'b1) ? data_s :
260                                             (VERIF_EN &lt; 1)        ? data_s :
261                                                                     ((data_s &amp; ~data_select) | (last_data_dyn &amp; data_select));
262                     
263                       assign data_s_sel_1 = (clk_d_stopped==1'b1) ? data_s :
264                                             (VERIF_EN &lt; 2)        ? {WIDTH{1'b0}} :
265                                                                     ((last_data_s_q &amp; ~data_select) | (last_data_s_qq &amp; data_select));
266                     
267                       assign data_s_int = ((data_s_sel_0 &amp; ~data_select_2) | (data_s_sel_1 &amp; data_select_2));
268                     
269                     // { START Latency Accurate modeling
270                       initial begin : set_setup_hold_delay_PROC
271                         `ifndef DW_HOLD_MUX_DELAY
272                           `define DW_HOLD_MUX_DELAY  1
273                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
274                             $display(&quot;Information: %m: *** Warning: `DW_HOLD_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_HOLD_MUX_DELAY);
275                         `endif
276                     
277                         `ifndef DW_SETUP_MUX_DELAY
278                           `define DW_SETUP_MUX_DELAY  1
279                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
280                             $display(&quot;Information: %m: *** Warning: `DW_SETUP_MUX_DELAY is not defined so it is being set to: %0d ***&quot;, `DW_SETUP_MUX_DELAY);
281                         `endif
282                       end // set_setup_hold_delay_PROC
283                     
284                       initial begin
285                         if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5))
286                           $display(&quot;Information: %m: *** Running with Latency Accurate MISSAMPLES defined, VERIF_EN is: %0d ***&quot;, VERIF_EN);
287                       end
288                     
289                       reg [WIDTH-1:0] setup_mux_ctrl, hold_mux_ctrl;
290                       initial setup_mux_ctrl = {WIDTH{1'b0}};
291                       initial hold_mux_ctrl  = {WIDTH{1'b0}};
292                       
293                       wire [WIDTH-1:0] data_s_q;
294                       reg clk_d_q;
295                       initial clk_d_q = 1'b0;
296                       reg [WIDTH-1:0] setup_mux_out, d_muxout;
297                       reg [WIDTH-1:0] d_ff1, d_ff2;
298                       integer i,j,k;
299                       
300                       
301                       //Delay the destination clock
302                       always @ (posedge clk_d)
303                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b1;
304                     
305                       always @ (negedge clk_d)
306                       #`DW_HOLD_MUX_DELAY clk_d_q = 1'b0;
307                       
308                       //Delay the source data
309                       assign #`DW_SETUP_MUX_DELAY data_s_q = (!rst_d_n) ? {WIDTH{1'b0}}:data_s;
310                     
311                       //setup_mux_ctrl controls the data entering the flip flop 
312                       always @ (data_s or data_s_q or setup_mux_ctrl) begin
313                         for (i=0;i&lt;=WIDTH-1;i=i+1) begin
314                           if (setup_mux_ctrl[i])
315                             setup_mux_out[i] = data_s_q[i];
316                           else
317                             setup_mux_out[i] = data_s[i];
318                         end
319                       end
320                     
321                       always @ (posedge clk_d_q or negedge rst_d_n) begin
322                         if (rst_d_n == 1'b0)
323                           d_ff2 &lt;= {WIDTH{1'b0}};
324                         else if (init_d_n == 1'b0)
325                           d_ff2 &lt;= {WIDTH{1'b0}};
326                         else if (test == 1'b1)
327                           d_ff2 &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
328                         else
329                           d_ff2 &lt;= setup_mux_out;
330                       end
331                     
332                       always @ (posedge clk_d or negedge rst_d_n) begin
333                         if (rst_d_n == 1'b0) begin
334                           d_ff1          &lt;= {WIDTH{1'b0}};
335                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
336                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
337                         end
338                         else if (init_d_n == 1'b0) begin
339                           d_ff1          &lt;= {WIDTH{1'b0}};
340                           setup_mux_ctrl &lt;= {WIDTH{1'b0}};
341                           hold_mux_ctrl  &lt;= {WIDTH{1'b0}};
342                         end
343                         else begin
344                           if (test == 1'b1)
345                             d_ff1        &lt;= (TST_MODE == 1) ? test_hold_ms : data_s;
346                           else
347                           d_ff1          &lt;= setup_mux_out;
348                           setup_mux_ctrl &lt;= wide_random(WIDTH);  //randomize mux_ctrl
349                           hold_mux_ctrl  &lt;= wide_random(WIDTH);  //randomize mux_ctrl
350                         end
351                       end
352                     
353                     
354                     //hold_mux_ctrl decides the clock triggering the flip-flop
355                     always @(hold_mux_ctrl or d_ff2 or d_ff1) begin
356                           for (k=0;k&lt;=WIDTH-1;k=k+1) begin
357                             if (hold_mux_ctrl[k])
358                               d_muxout[k] = d_ff2[k];
359                             else
360                               d_muxout[k] = d_ff1[k];
361                           end
362                     end
363                     // END Latency Accurate modeling }
364                     
365                     
366                      //Assertions
367                     `ifdef DWC_BCM_SNPS_ASSERT_ON
368                     `ifndef SYNTHESIS
369                     generate if ((F_SYNC_TYPE == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_ASSERT_FST2_VE5
370                       sequence p_num_d_chng;
371                       @ (posedge clk_d) 1'b1 ##0 (data_s != d_ff1); //Number of times input data changed
372                       endsequence
373                       
374                       sequence p_num_d_chng_hmux1;
375                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times hold_mux_ctrl was asserted when the input data changed
376                       endsequence
377                       
378                       sequence p_num_d_chng_smux1;
379                       @ (posedge clk_d) 1'b1 ##0 ((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))); //Number of times setup_mux_ctrl was asserted when the input data changed
380                       endsequence
381                       
382                       sequence p_hold_vio;
383                       reg [WIDTH-1:0]temp_var, temp_var1;
384                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(hold_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(hold_mux_ctrl &amp; (data_s ^ d_ff1))) ##1 ((data_d &amp; temp_var1) == (temp_var &amp; temp_var1));
385                               //Number of times output data was advanced due to hold violation
386                       endsequence
387                       
388                       sequence p_setup_vio;
389                       reg [WIDTH-1:0]temp_var, temp_var1;
390                       @ (posedge clk_d) (((data_s != d_ff1) &amp;&amp; (|(setup_mux_ctrl &amp; (data_s ^ d_ff1)))), temp_var = data_s, temp_var1 =(setup_mux_ctrl &amp; (data_s ^ d_ff1))) ##2 ((data_d &amp; temp_var1) != (temp_var &amp; temp_var1));
391                               //Number of times output data was delayed due to setup violation
392                       endsequence
393                     
394                       cp_num_d_chng           : cover property  (p_num_d_chng);    
395                       cp_num_d_chng_hld_mux1  : cover property  (p_num_d_chng_hmux1);
396                       cp_num_d_chng_set_mux1  : cover property  (p_num_d_chng_smux1);
397                       cp_hold_vio             : cover property  (p_hold_vio);
398                       cp_setup_vio            : cover property  (p_setup_vio);        
399                      end
400                     endgenerate
401                     `endif // SYNTHESIS
402                     `endif // DWC_BCM_SNPS_ASSERT_ON
403                     
404                       function [WIDTH-1:0] wide_random;
405                         input [31:0]        in_width;   // should match &quot;WIDTH&quot; parameter -- need one input to satisfy Verilog function requirement
406                     
407                         reg   [WIDTH-1:0]   temp_result;
408                         reg   [31:0]        rand_slice;
409                         integer             i, j, base;
410                     
411                     
412                         begin
413                     `ifdef DWC_BCM_SV
414                           temp_result = $urandom;
415                     `else
416                           temp_result = $random;
417                     `endif
418                           if (((WIDTH / 32) + 1) &gt; 1) begin
419                             for (i=1 ; i &lt; ((WIDTH / 32) + 1) ; i=i+1) begin
420                               base = i &lt;&lt; 5;
421                     `ifdef DWC_BCM_SV
422                               rand_slice = $urandom;
423                     `else
424                               rand_slice = $random;
425                     `endif
426                               for (j=0 ; ((j &lt; 32) &amp;&amp; (base+j &lt; in_width)) ; j=j+1) begin
427                                 temp_result[base+j] = rand_slice[j];
428                               end
429                             end
430                           end
431                     
432                           wide_random = temp_result;
433                         end
434                       endfunction  // wide_random
435                     
436                       initial begin : seed_random_PROC
437                         integer seed, init_rand;
438                         `ifdef DW_MISSAMPLE_SEED
439                           if (`DW_MISSAMPLE_SEED != 0)
440                             seed = `DW_MISSAMPLE_SEED;
441                           else
442                             seed = 32'h0badbeef;
443                         `else
444                           seed = 32'h0badbeef;
445                         `endif
446                     
447                     `ifdef DWC_BCM_SV
448                         init_rand = $urandom(seed);
449                     `else
450                         init_rand = $random(seed);
451                     `endif
452                       end // seed_random_PROC
453                     
454                     
455                       `else
456                       assign data_s_int = data_s;
457                       `endif
458                     `endif
459                     
460                     
461                     // spyglass disable_block Ac_glitch03
462                     // SMD: Reports clock domain crossings subject to glitches
463                     // SJ: The possible glitch only occur in test mode, which does not affect the normal function.
464                     // spyglass disable_block Ac_conv04
465                     // SMD: Checks all the control-bus clock domain crossings which do not follow gray encoding
466                     // SJ: The clock domain crossing bus is between the register file and the read-mux of a RAM, which do not need a gray encoding.
467                     
468                     generate
469                         if ((F_SYNC_TYPE &amp; 7) == 0) begin : GEN_FST0
470                           if (TST_MODE == 1) begin : GEN_DATAD_FST0_TM1
471                             reg    [WIDTH-1:0]      test_hold;
472                     // spyglass disable_block Clock_check04
473                     // SMD: Use rising edge flipflop
474                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
475                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
476                     // spyglass enable_block Clock_check04
477                               if (rst_d_n == 1'b0) begin
478                                 test_hold        &lt;= {WIDTH{1'b0}};
479                               end else if (init_d_n == 1'b0) begin
480                                 test_hold        &lt;= {WIDTH{1'b0}};
481                               end else begin
482                     // spyglass disable_block W391
483                     // SMD: Design has a clock driving it on both edges
484                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
485                     // spyglass disable_block Ac_unsync02
486                     // SMD: Checks unsynchronized crossing for vector signals
487                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
488                     // spyglass disable_block Ar_resetcross01
489                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
490                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
491                                 test_hold        &lt;= data_s;
492                     // spyglass enable_block W391
493                     // spyglass enable_block Ac_unsync02
494                     // spyglass enable_block Ar_resetcross01
495                               end
496                             end
497                     
498                             assign data_d  = (test == 1'b1) ? test_hold : data_s;
499                           end else begin : GEN_DATAD_FST0_TM_NE_1
500                             assign data_d  =  data_s;
501                           end
502                         end
503                         if ((F_SYNC_TYPE &amp; 7) == 1) begin : GEN_FST1
504                           reg    [WIDTH-1:0]      sample_meta_n;
505                           reg    [WIDTH-1:0]      sample_syncl;
506                           wire   [WIDTH-1:0]      next_sample_syncm1;
507                           wire   [WIDTH-1:0]      next_sample_syncl;
508                     
509                     // spyglass disable_block Clock_check04
510                     // SMD: Use rising edge flipflop
511                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
512                           always @ (negedge clk_d or negedge rst_d_n) begin : negedge_registers_PROC
513                     // spyglass enable_block Clock_check04
514                             if (rst_d_n == 1'b0) begin
515                               sample_meta_n    &lt;= {WIDTH{1'b0}};
516                             end else if (init_d_n == 1'b0) begin
517                               sample_meta_n    &lt;= {WIDTH{1'b0}};
518                             end else begin
519                     // spyglass disable_block W391
520                     // SMD: Design has a clock driving it on both edges
521                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
522                               sample_meta_n    &lt;= data_s_int;
523                     // spyglass enable_block W391
524                             end
525                           end
526                     
527                           assign next_sample_syncm1 = sample_meta_n;
528                           assign next_sample_syncl = next_sample_syncm1;
529                     
530                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
531                             if (rst_d_n == 1'b0) begin
532                               sample_syncl     &lt;= {WIDTH{1'b0}};
533                             end else if (init_d_n == 1'b0) begin
534                               sample_syncl     &lt;= {WIDTH{1'b0}};
535                             end else begin
536                     // spyglass disable_block W391
537                     // SMD: Design has a clock driving it on both edges
538                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
539                               sample_syncl     &lt;= next_sample_syncl;
540                     // spyglass enable_block W391
541                             end
542                           end
543                     
544                           assign data_d = sample_syncl;
545                         end
546                         if ((F_SYNC_TYPE &amp; 7) == 2) begin : GEN_FST2
547                           reg    [WIDTH-1:0]      sample_meta;
548                           reg    [WIDTH-1:0]      sample_syncl;
549                           wire   [WIDTH-1:0]      next_sample_meta;
550                           wire   [WIDTH-1:0]      next_sample_syncm1;
551                           wire   [WIDTH-1:0]      next_sample_syncl;
552                     
553                           if (TST_MODE == 1) begin : GEN_TST_MODE1
554                             reg    [WIDTH-1:0]      test_hold;
555                     
556                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : test_hold;
557                     
558                     // spyglass disable_block Clock_check04
559                     // SMD: Use rising edge flipflop
560                     // SJ: The module was intentionally implemented to use negative edge clocking flip-flops cells.
561                             always @ (negedge clk_d or negedge rst_d_n) begin : test_hold_registers_PROC
562                     // spyglass enable_block Clock_check04
563                               if (rst_d_n == 1'b0) begin
564                                 test_hold        &lt;= {WIDTH{1'b0}};
565                               end else if (init_d_n == 1'b0) begin
566                                 test_hold        &lt;= {WIDTH{1'b0}};
567                               end else begin
568                     // spyglass disable_block W391
569                     // SMD: Design has a clock driving it on both edges
570                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
571                     // spyglass disable_block Ac_unsync02
572                     // SMD: Checks unsynchronized crossing for vector signals
573                     // SJ: This circuit is not just during normal operation and synchronization functionality is not required during its use.
574                     // spyglass disable_block Ar_resetcross01
575                     // SMD: There are paths between two sequential elements that are clocked by the same clock domain but have different asynchronous resets/sets
576                     // SJ: When used in a reset synchronizer. Reset crossing is expected.
577                                 test_hold        &lt;= data_s;
578                     // spyglass enable_block W391
579                     // spyglass enable_block Ac_unsync02
580                     // spyglass enable_block Ar_resetcross01
581                               end
582                             end
583                           end else begin : GEN_TST_MODE0
584                             assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
585                           end
586                     
587                     
588                     `ifdef SYNTHESIS
589                           assign next_sample_syncm1 = sample_meta;
590                     `else
591                       `ifdef DW_MODEL_MISSAMPLES
592                           if (((F_SYNC_TYPE &amp; 7) == 2) &amp;&amp; (VERIF_EN == 5)) begin : GEN_NXT_SMPL_SM1_FST2_VE5
593                             assign next_sample_syncm1 = d_muxout;
594                           end else begin : GEN_NXT_SMPL_SM1_ELSE
595                             assign next_sample_syncm1 = sample_meta;
596                           end
597                       `else
598                             assign next_sample_syncm1 = sample_meta;
599                       `endif
600                     `endif
601                           assign next_sample_syncl = next_sample_syncm1;
602                           always @ (posedge clk_d or negedge rst_d_n) begin : posedge_registers_PROC
603        1/1                  if (rst_d_n == 1'b0) begin
604        1/1                    sample_meta     &lt;= {WIDTH{1'b0}};
605        1/1                    sample_syncl     &lt;= {WIDTH{1'b0}};
606        1/1                  end else if (init_d_n == 1'b0) begin
607        <font color = "red">0/1     ==>            sample_meta     &lt;= {WIDTH{1'b0}};</font>
608        <font color = "red">0/1     ==>            sample_syncl     &lt;= {WIDTH{1'b0}};</font>
609                             end else begin
610                     // spyglass disable_block W391
611                     // SMD: Design has a clock driving it on both edges
612                     // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613        1/1                    sample_meta     &lt;= next_sample_meta;
614        1/1                    sample_syncl     &lt;= next_sample_syncl;
</pre>
<hr>
<a name="inst_tag_19_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod16.html#inst_tag_19" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">Conditions</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s5"><td class="lf">Logical</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       584
 EXPRESSION ((test == 1'b0) ? data_s_int : data_s)
             -------1------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th></tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_19_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod16.html#inst_tag_19" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s8">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">10</td>
<td class="rt">83.33 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">56</td>
<td class="rt">52</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">28</td>
<td class="rt">26</td>
<td class="rt">92.86 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s6">
<td>Ports</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">20</td>
<td class="rt">16</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 0->1</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">10</td>
<td class="rt">8</td>
<td class="rt">80.00 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">36</td>
<td class="rt">36</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">18</td>
<td class="rt">18</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>clk_d</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rst_d_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>init_d_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_s[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>test</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>data_d[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>data_s_int[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_meta[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncm1[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>GEN_FST2.next_sample_syncl[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="inst_tag_19_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod16.html#inst_tag_19" >axi_bus_top.DW_axi_x2p_u.U_CMD_QUEUE.U_CMD_FIFO_CONTROL_S2.U_POP_FIFOFCTL.U_sync</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">584</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">86</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">603</td>
<td class="rt">3</td>
<td class="rt">2</td>
<td class="rt">66.67 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
584                assign next_sample_meta      = (test == 1'b0) ? data_s_int : data_s;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
86             if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
               <font color = "red">-1-</font>  
87                $display("Information: *** Instance %m module is using the <Double Register Synchronizer (1)> Clock Domain Crossing Method ***");
           <font color = "red">       ==></font>
                  MISSING_ELSE
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
603                if (rst_d_n == 1'b0) begin
                   <font color = "green">-1-</font>  
604                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "green">          ==></font>
605                  sample_syncl     <= {WIDTH{1'b0}};
606                end else if (init_d_n == 1'b0) begin
                            <font color = "red">-2-</font>  
607                  sample_meta     <= {WIDTH{1'b0}};
           <font color = "red">          ==></font>
608                  sample_syncl     <= {WIDTH{1'b0}};
609                end else begin
610        // spyglass disable_block W391
611        // SMD: Design has a clock driving it on both edges
612        // SJ: This module is configured such that both edges of the same clock are used for different flip-flops.
613                  sample_meta     <= next_sample_meta;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_18">
    <li>
      <a href="#inst_tag_18_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_18_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_18_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_18_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_19">
    <li>
      <a href="#inst_tag_19_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_19_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_19_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_19_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_20">
    <li>
      <a href="#inst_tag_20_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_20_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_20_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_20_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_21">
    <li>
      <a href="#inst_tag_21_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_21_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_21_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_21_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_22">
    <li>
      <a href="#inst_tag_22_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_22_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_22_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_22_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_23">
    <li>
      <a href="#inst_tag_23_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_23_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_23_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_23_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_24">
    <li>
      <a href="#inst_tag_24_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_24_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_24_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_24_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_25">
    <li>
      <a href="#inst_tag_25_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_25_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_25_Toggle">Toggle</a>    </li>
    <li>
      <a href="#inst_tag_25_Branch">Branch</a>    </li>
  </ul>
  <ul name="tag_DW_axi_x2p_bcm21">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
